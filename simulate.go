package sequence

// Simulation creates a sequence where an initial state is updated by a function
// that produces a new state, and indicates if there is more work to be done.
// The sequence of states is expected to be deterministic given the initial
// state and the step function, if not, the sequence should be marked volatile.
// The output sequence returns the series of states created from the initial
// state to the final state.
//
// Logically, this is equivalent to [Single](initial).[Simulate](step), but
// slightly faster due to avoiding creating and iterating the first sequence.
func Simulation[T any](initial T, step func(T) (T, bool)) Sequence[T] {
	return Generate(func(f func(T) error) error {
		for state, more := initial, true; more; state, more = step(state) {
			if err := f(state); err != nil {
				return err
			}
		}
		return nil
	})
}

// Simulate produces a sequence where items are generated by taking the
// previously generated item, and running it through a step function that
// returns a new item, and whether or not there are more values to come.
// This process is fed by the provided sequence where the final element of that
// sequence is the initial value to step. The final returned sequence is the
// concatenation of the starting sequence and the simulated elements.
// The generated sequence will be volatile if the input sequence is volatile.
func Simulate[T any](prev Sequence[T], step func(T) (T, bool)) Sequence[T] {
	return Derive(prev, func(f func(T) error) error {
		var last T
		if err := prev.Each(func(t T) error { last = t; return f(t) }); err != nil {
			return err
		}
		for state, more := step(last); more; state, more = step(state) {
			if err := f(state); err != nil {
				return err
			}
		}
		return nil
	})
}

// Simulate is a helper method to call the package function [Simulate] on the
// receiver to produce new simulated values to extend the current sequence.
func (s Sequence[T]) Simulate(step func(T) (T, bool)) Sequence[T] {
	return Simulate(s, step)
}

// SimulateOne is like [Simulate] except that a single step is unconditionally
// done, producing a sequence that has one more element than the input. The new
// sequence is produced using [Derive] so will retain the properties of the
// input sequence.
func SimulateOne[T any](prev Sequence[T], step func(T) T) Sequence[T] {
	return Derive(prev, func(f func(T) error) error {
		var last T
		if err := prev.Each(func(t T) error { last = t; return f(t) }); err != nil {
			return err
		}
		return f(step(last))
	})
}

// SimulateOne is a helper method to call the package function [SimulateOne] on
// the receiver to produce a sequence with a simulated value added to the end.
func (s Sequence[T]) SimulateOne(step func(T) T) Sequence[T] {
	return SimulateOne(s, step)
}
